
# Types and Type Differences

**1. What is the difference between `int` and `Int32` in C#?**

**Answer :**

`int` is simply an alias for `System.Int32` in C#. Both represent a 32-bit signed integer and are completely identical in functionality.
The alias exists to improve readability and convenience in the C# language.

```Csharp
class Program
{
    static void Main()
    {
        int a = 10;
        Int32 b = 20; // int is an alias for Int32

        Console.WriteLine(a + b); // Outputs 30
    }
}
```

**2. What is the difference between `float`, `double`, and `decimal` in C#? When would you use each?**

**Answer :**

* **float**: 32-bit single-precision floating-point type, suitable when memory usage is critical and precision is less important.
* **double**: 64-bit double-precision floating-point type, commonly used for general-purpose calculations.
* **decimal**: 128-bit high-precision type, ideal for financial and monetary calculations where accuracy is critical.

```Csharp
class Program
{
    static void Main()
    {
        float f = 3.14f;
        double d = 3.14159;
        decimal m = 3.14159m;

        Console.WriteLine($"Float: {f}, Double: {d}, Decimal: {m}");
    }
}
```

**3. What is the difference between `struct` and `class` in C#?**

**Answer :**

* **struct**: A value type, usually stored on the stack, copied by value. Best suited for small, simple data structures.
* **class**: A reference type, stored on the heap, copied by reference. Suitable for complex objects and supports inheritance.

```Csharp
struct PointStruct
{
    public int X, Y;
}

class PointClass
{
    public int X, Y;
}

class Program
{
    static void Main()
    {
        PointStruct pStruct = new PointStruct { X = 10, Y = 20 };
        PointClass pClass = new PointClass { X = 10, Y = 20 };

        PointStruct pStructCopy = pStruct;
        PointClass pClassCopy = pClass;

        pStructCopy.X = 100;
        pClassCopy.X = 100;

        Console.WriteLine($"Struct original: {pStruct.X}, copy: {pStructCopy.X}");
        Console.WriteLine($"Class original: {pClass.X}, copy: {pClassCopy.X}");
    }
}
```

**4. What is the difference between a reference type and a value type in C#?**

**Answer :**

* **Value types** store data directly and are copied by value.
* **Reference types** store a reference to data on the heap, and multiple variables can reference the same object.

```Csharp
struct ValueType
{
    public int Data;
}

class ReferenceType
{
    public int Data;
}

class Program
{
    static void Main()
    {
        ValueType value1 = new ValueType { Data = 10 };
        ValueType value2 = value1;
        value2.Data = 20;

        ReferenceType ref1 = new ReferenceType { Data = 10 };
        ReferenceType ref2 = ref1;
        ref2.Data = 20;

        Console.WriteLine($"Value Type: {value1.Data}");
        Console.WriteLine($"Reference Type: {ref1.Data}");
    }
}
```

**5. What is the difference between `dynamic` and `var` in C#?**

**Answer :**

* **var**: Type is inferred at compile time and cannot change.
* **dynamic**: Type is resolved at runtime, bypassing compile-time type checking.

```Csharp
class Program
{
    static void Main()
    {
        var a = 10;
        // a = "string"; // Compile-time error

        dynamic b = 10;
        b = "string"; // Allowed, resolved at runtime

        Console.WriteLine(b);
    }
}
```

**6. What is the difference between `object` and `dynamic` in C#?**

**Answer :**

* **object**: Base type of all types; requires explicit casting for operations.
* **dynamic**: Operations are resolved at runtime without compile-time checks.

```Csharp
class Program
{
    static void Main()
    {
        object obj = 10;
        // Console.WriteLine(obj + 5); // Compile-time error

        dynamic dyn = 10;
        Console.WriteLine(dyn + 5); // Runtime resolution
    }
}
```

**7. What is the difference between nullable and non-nullable types in C#?**

**Answer :**

* **Non-nullable types** must always have a value.
* **Nullable types (`T?`)** can hold both a value and `null`.

```Csharp
class Program
{
    static void Main()
    {
        int nonNullable = 10;
        // nonNullable = null; // Error

        int? nullable = null;
        nullable = 20;

        Console.WriteLine(nullable.HasValue ? nullable.Value.ToString() : "null");
    }
}
```

**8. How does type casting work in C#? What are implicit and explicit casts?**

**Answer :**

* **Implicit casting** occurs automatically when there is no risk of data loss.
* **Explicit casting** requires a cast operator and may result in data loss.

```Csharp
class Program
{
    static void Main()
    {
        int a = 10;
        double b = a; // Implicit cast

        double c = 9.8;
        int d = (int)c; // Explicit cast

        Console.WriteLine(b);
        Console.WriteLine(d);
    }
}
```

**9. What is the difference between `is` and `as` operators in C#?**

**Answer :**

* **is** checks type compatibility and returns a boolean.
* **as** attempts a safe cast and returns `null` if it fails.

```Csharp
class Animal { }
class Dog : Animal { }

class Program
{
    static void Main()
    {
        Animal animal = new Dog();

        if (animal is Dog)
        {
            Console.WriteLine("Animal is a Dog.");
        }

        Dog dog = animal as Dog;
        if (dog != null)
        {
            Console.WriteLine("Successfully cast to Dog.");
        }
    }
}
```

**10. How does the `typeof` keyword differ from `GetType()` in C#?**

**Answer :**

* **typeof** retrieves type information at compile time.
* **GetType()** retrieves the runtime type of an object instance.

```Csharp
class Animal { }

class Program
{
    static void Main()
    {
        Type type1 = typeof(Animal);
        Console.WriteLine(type1);

        Animal animal = new Animal();
        Type type2 = animal.GetType();
        Console.WriteLine(type2);
    }
}
```

**11. What is the difference between `enum` and `const` in C#?**

**Answer :**

* **enum** represents a set of named constants as a distinct type.
* **const** defines a single compile-time constant value.

```Csharp
enum Days { Sunday, Monday, Tuesday }

class Program
{
    const int MaxValue = 100;

    static void Main()
    {
        Days day = Days.Monday;
        Console.WriteLine($"Day: {day}, MaxValue: {MaxValue}");
    }
}
```

**12. What is a delegate in C#, and how does it differ from `Func` or `Action`?**

**Answer :**

A delegate represents a reference to a method with a specific signature.
`Func` and `Action` are built-in delegates where `Func` returns a value and `Action` does not.

```Csharp
public delegate int MathOperation(int x, int y);

class Program
{
    static int Add(int x, int y) => x + y;

    static void Main()
    {
        MathOperation operation = Add;
        Console.WriteLine(operation(5, 10));

        Func<int, int, int> funcOperation = Add;
        Console.WriteLine(funcOperation(5, 10));
    }
}
```

**13. What are type parameters in C#, and how do they work with generics?**

**Answer :**

Type parameters allow generic classes and methods to operate on any data type while maintaining type safety.

```Csharp
class GenericBox<T>
{
    public T Value { get; set; }
}

class Program
{
    static void Main()
    {
        GenericBox<int> intBox = new GenericBox<int> { Value = 10 };
        GenericBox<string> strBox = new GenericBox<string> { Value = "Hello" };

        Console.WriteLine($"Int Box: {intBox.Value}, String Box: {strBox.Value}");
    }
}
```

**14. How does method overloading differ from method overriding in C#?**

**Answer :**

* **Overloading**: Same method name with different parameters in the same class.
* **Overriding**: Derived class provides a new implementation of a base class method.

```Csharp
class BaseClass
{
    public virtual void Display() => Console.WriteLine("BaseClass Display");
}

class DerivedClass : BaseClass
{
    public override void Display() => Console.WriteLine("DerivedClass Display");

    public void Display(string message) => Console.WriteLine(message);
}

class Program
{
    static void Main()
    {
        DerivedClass derived = new DerivedClass();
        derived.Display();
        derived.Display("Hello");
    }
}
```

**15. How does the `default` keyword work in C#, especially with generics?**

**Answer :**

`default` returns the default value of a type.
In generics, it allows code to work without knowing the exact type at compile time.

```Csharp
class Program
{
    static T GetDefaultValue<T>()
    {
        return default(T);
    }

    static void Main()
    {
        Console.WriteLine(GetDefaultValue<int>());
        Console.WriteLine(GetDefaultValue<string>());
    }
}
```

**16. What is the difference between implicit and explicit type conversion in C#?**

**Answer :**

* **Implicit conversion** happens automatically when safe.
* **Explicit conversion** requires casting and may lose data.

```Csharp
class Program
{
    static void Main()
    {
        int num = 100;
        double numDouble = num;

        double value = 9.8;
        int valueInt = (int)value;

        Console.WriteLine($"Implicit: {numDouble}, Explicit: {valueInt}");
    }
}
```

**17. How does the nullable feature work in C# with value types?**

**Answer :**

Nullable value types (`T?`) allow value types to represent `null` in addition to valid values.

```Csharp
class Program
{
    static void Main()
    {
        int? nullableInt = null;

        if (nullableInt.HasValue)
            Console.WriteLine(nullableInt.Value);
        else
            Console.WriteLine("Value is null");
    }
}
```

**18. How do `ref` and `out` differ when passing parameters in C#?**

**Answer :**

* **ref**: Variable must be initialized before passing.
* **out**: Variable does not need to be initialized but must be assigned inside the method.

```Csharp
class Program
{
    static void ModifyRef(ref int a) => a = 20;
    static void ModifyOut(out int a) => a = 30;

    static void Main()
    {
        int refValue = 10;
        ModifyRef(ref refValue);
        Console.WriteLine(refValue);

        int outValue;
        ModifyOut(out outValue);
        Console.WriteLine(outValue);
    }
}
```
