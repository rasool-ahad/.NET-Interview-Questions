# Collections and LINQ

## 1. What is the difference between ‘IEnumerable‘, ‘ICollection‘, and ‘IList‘ in C#?

**Answer :**

* **IEnumerable**: Forward-only iteration, minimal methods.
* **ICollection**: Inherits IEnumerable, adds Add/Remove/Count.
* **IList**: Inherits ICollection, provides index-based access.

```csharp
class Program
{
    static void Main ()
    {
        // IEnumerable : Only allows iteration
        IEnumerable<int> enumerable = new List<int> { 1, 2, 3 };
        foreach (var item in enumerable)
        {
            Console.WriteLine(item);
        }

        // ICollection : Allows adding / removing
        ICollection<int> collection = new List<int> { 1, 2, 3 };
        collection.Add(4);
        collection.Remove(2);

        // IList : Allows index - based access
        IList<int> list = new List<int> { 1, 2, 3 };
        list[1] = 10;
        list.Insert(2, 5);
        Console.WriteLine(string.Join(", ", list)); // Outputs : 1, 10, 5, 3
    }
}
```

## 2. How does deferred execution work in LINQ, and why is it useful?

**Answer :**

LINQ queries aren’t executed until the data is actually requested.
This defers expensive operations and allows combining multiple queries before execution.

```csharp
class Program
{
    static void Main ()
    {
        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };

        // Deferred execution : query is not executed until we enumerate over it
        var query = numbers.Where(n => n > 2);

        numbers.Add(6); // Adding to the list before enumeration

        // Now the query is executed
        foreach (var number in query)
        {
            Console.WriteLine(number); // Outputs : 3, 4, 5, 6
        }
    }
}
```

## 3. What is the difference between ‘First‘, ‘FirstOrDefault‘, ‘Single‘, and ‘SingleOrDefault‘ in LINQ? When should each be used?

**Answer :**

* **First**: Returns the first element, throws if empty.
* **FirstOrDefault**: Returns the first element or a default if empty.
* **Single**: Returns exactly one element, throws if none or more than one.
* **SingleOrDefault**: Returns exactly one element or default if empty, throws if more than one.

```csharp
class Program
{
    static void Main ()
    {
        List<int> numbers = new List<int> { 1, 2, 3 };

        // First : throws if empty , returns first element
        int first = numbers.First();

        // FirstOrDefault : returns default if empty
        int firstOrDefault = numbers.FirstOrDefault();

        // Single : expects only one element , throws if more than one
        int single = numbers.Where(n => n == 2).Single();

        // SingleOrDefault : returns single element or default , throws if more than one
        int singleOrDefault = numbers.Where(n => n == 2).SingleOrDefault();
    }
}
```

## 4. How does the ‘SelectMany‘ method differ from ‘Select‘ in LINQ?

**Answer :**

‘Select‘ projects each element into a new form, while ‘SelectMany‘ flattens sequences of sequences into a single sequence.

```csharp
class Program
{
    static void Main ()
    {
        // Using Select : Returns an IEnumerable of IEnumerable
        List<List<int>> numbers = new List<List<int>>
        {
            new List<int> { 1, 2 },
            new List<int> { 3, 4 }
        };

        var selectResult = numbers.Select(list => list);

        // Using SelectMany : Flattens the lists into a single sequence
        var selectManyResult = numbers.SelectMany(list => list);

        Console.WriteLine(string.Join(", ", selectManyResult)); // Outputs : 1, 2, 3, 4
    }
}
```

---

## 5. How does LINQ handle filtering with ‘Where‘, and how does it work with complex objects?

**Answer :**

‘Where‘ filters a sequence based on a predicate.
It applies to any object type by specifying the condition in a lambda expression.

```csharp
class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

class Program
{
    static void Main ()
    {
        List<Person> people = new List<Person>
        {
            new Person { Name = "Alice", Age = 30 },
            new Person { Name = "Bob", Age = 40 },
            new Person { Name = "Charlie", Age = 25 }
        };

        // Filtering using Where on complex objects
        var adults = people.Where(p => p.Age >= 30);

        foreach (var person in adults)
        {
            Console.WriteLine(person.Name); // Outputs : Alice , Bob
        }
    }
}
```

## 6. What is the purpose of ‘GroupBy‘ in LINQ, and how does it work?

**Answer :**

‘GroupBy‘ groups elements by a key selector and returns an `IEnumerable<IGrouping<TKey, TElement>>`,
where each grouping has a key and its related items.

```csharp
class Person
{
    public string Name { get; set; }
    public string Department { get; set; }
}

class Program
{
    static void Main ()
    {
        List<Person> people = new List<Person>
        {
            new Person { Name = "Alice", Department = "HR" },
            new Person { Name = "Bob", Department = "IT" },
            new Person { Name = "Charlie", Department = "IT" }
        };

        // Group by department
        var groupedByDepartment = people.GroupBy(p => p.Department);

        foreach (var group in groupedByDepartment)
        {
            Console.WriteLine($"Department : {group.Key}");
            foreach (var person in group)
            {
                Console.WriteLine($" - {person.Name}");
            }
        }
    }
}
```

## 7. How does ‘ToDictionary‘ work in LINQ, and what are some potential pitfalls?

**Answer :**

‘ToDictionary‘ converts a sequence into a `Dictionary<TKey, TValue>` using key/value selectors.
A pitfall is duplicate keys, which cause an exception.

```csharp
class Person
{
    public string Name { get; set; }
    public int Id { get; set; }
}

class Program
{
    static void Main ()
    {
        List<Person> people = new List<Person>
        {
            new Person { Name = "Alice", Id = 1 },
            new Person { Name = "Bob", Id = 2 }
        };

        // Converting to a Dictionary where key is Id and value is Name
        Dictionary<int, string> peopleDict =
            people.ToDictionary(p => p.Id, p => p.Name);

        // Accessing the dictionary
        Console.WriteLine(peopleDict[1]); // Outputs : Alice
    }
}
```

## 8. How do LINQ ‘Join‘ and ‘GroupJoin‘ differ, and when should each be used?

**Answer :**

* **Join**: Combines two sequences based on matching keys, similar to an inner join.
* **GroupJoin**: Groups the matching elements from the second sequence, akin to a left join.

```csharp
class Employee
{
    public int Id { get; set; }
    public string Name { get; set; }
}

class Department
{
    public int DepartmentId { get; set; }
    public string DepartmentName { get; set; }
}

class Program
{
    static void Main ()
    {
        List<Employee> employees = new List<Employee>
        {
            new Employee { Id = 1, Name = "Alice" },
            new Employee { Id = 2, Name = "Bob" }
        };

        List<Department> departments = new List<Department>
        {
            new Department { DepartmentId = 1, DepartmentName = "HR" },
            new Department { DepartmentId = 2, DepartmentName = "IT" }
        };

        // Join example
        var joinResult = employees.Join(
            departments,
            e => e.Id,
            d => d.DepartmentId,
            (e, d) => new { e.Name, d.DepartmentName }
        );

        // GroupJoin example ( left outer join )
        var groupJoinResult = departments.GroupJoin(
            employees,
            d => d.DepartmentId,
            e => e.Id,
            (d, es) => new { d.DepartmentName, Employees = es }
        );
    }
}
```

## 9.What is the difference between ‘OrderBy‘ and ‘ThenBy‘ in LINQ?

**Answer :**

* **OrderBy**: Sorts items in ascending order by a key.
* **ThenBy**: Specifies a secondary sort for items that matched the primary sort.

```csharp
class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

class Program
{
    static void Main ()
    {
        List<Person> people = new List<Person>
        {
            new Person { Name = "Alice", Age = 30 },
            new Person { Name = "Bob", Age = 25 },
            new Person { Name = "Charlie", Age = 30 }
        };

        // Sort by Age , then by Name for people with the same Age
        var sortedPeople = people.OrderBy(p => p.Age).ThenBy(p => p.Name);

        foreach (var person in sortedPeople)
        {
            Console.WriteLine($"{person.Name}, {person.Age}");
        }
    }
}
```

## 10.What is the purpose of ‘Distinct‘ in LINQ, and how does it determine uniqueness?

**Answer :**

‘Distinct‘ removes duplicate elements from a sequence by using the default or custom equality comparer.

```csharp
class Program
{
    static void Main ()
    {
        List<int> numbers = new List<int> { 1, 2, 2, 3, 4, 4, 5 };

        // Using Distinct to eliminate duplicates
        var distinctNumbers = numbers.Distinct();

        Console.WriteLine(string.Join(", ", distinctNumbers)); // Outputs : 1, 2, 3, 4, 5
    }
}
```

## 11.How does ‘Zip‘ work in LINQ, and when would you use it?

**Answer :**

‘Zip‘ pairs up elements from two sequences by index, stopping when the shorter sequence ends, and applies a function to each pair.

```csharp
class Program
{
    static void Main ()
    {
        var numbers = new List<int> { 1, 2, 3 };
        var letters = new List<char> { 'A', 'B', 'C' };

        // Zipping numbers with letters
        var zipped = numbers.Zip(letters, (n, l) => $"{n}-{l}");

        foreach (var item in zipped)
        {
            Console.WriteLine(item); // Outputs : 1-A, 2-B, 3-C
        }
    }
}
```

## 12.How can ‘Any‘ and ‘All‘ be used for validation in LINQ?

**Answer :**

* **Any**: Checks if at least one element satisfies a condition or if the sequence has elements.
* **All**: Checks if all elements satisfy a condition.

```csharp
class Program
{
    static void Main ()
    {
        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };

        // Check if any number is greater than 4
        bool anyGreaterThanFour = numbers.Any(n => n > 4); // True

        // Check if all numbers are positive
        bool allPositive = numbers.All(n => n > 0); // True

        Console.WriteLine(anyGreaterThanFour); // Outputs : True
        Console.WriteLine(allPositive); // Outputs : True
    }
}
```

## 13.What is ‘Aggregate‘ in LINQ, and how does it differ from ‘Sum‘, ‘Count‘, etc.?

**Answer :**

‘Aggregate‘ applies a custom accumulator function over a sequence, whereas methods like ‘Sum‘ or ‘Count‘ are specific built-in aggregations.

```csharp
class Program
{
    static void Main ()
    {
        List<int> numbers = new List<int> { 1, 2, 3, 4 };

        // Using Aggregate to compute product of all numbers
        int product = numbers.Aggregate((acc, n) => acc * n);

        Console.WriteLine(product); // Outputs : 24 (1 * 2 * 3 * 4)
    }
}
```

## 14.How does ‘Except‘ differ from ‘Intersect‘ in LINQ?

**Answer :**

* **Except**: Returns elements in the first sequence not in the second.
* **Intersect**: Returns elements present in both sequences.

```csharp
class Program
{
    static void Main ()
    {
        List<int> list1 = new List<int> { 1, 2, 3, 4 };
        List<int> list2 = new List<int> { 3, 4, 5, 6 };

        // Elements in list1 but not in list2
        var exceptResult = list1.Except(list2);
        Console.WriteLine(string.Join(", ", exceptResult)); // Outputs : 1, 2

        // Elements common to both lists
        var intersectResult = list1.Intersect(list2);
        Console.WriteLine(string.Join(", ", intersectResult)); // Outputs : 3, 4
    }
}
```

## 15.How does ‘Select‘ with index work in LINQ, and why would you use it?

**Answer :**

‘Select‘ can include the zero-based index in the projection.
Useful for transformations that need both the item and its index.

```csharp
class Program
{
    static void Main ()
    {
        var fruits = new List<string> { "Apple", "Banana", "Cherry" };

        // Using Select with index
        var indexedFruits = fruits.Select((fruit, index) => $"{index}: {fruit}");

        foreach (var item in indexedFruits)
        {
            Console.WriteLine(item); // Outputs : 0: Apple , 1: Banana , 2: Cherry
        }
    }
}
```

## 16.How can you use ‘Concat‘ and ‘Union‘ in LINQ, and what is the difference?

**Answer :**

* **Concat**: Merges two sequences end to end, keeping duplicates.
* **Union**: Merges two sequences and removes duplicates.

```csharp
class Program
{
    static void Main ()
    {
        var list1 = new List<int> { 1, 2, 3 };
        var list2 = new List<int> { 3, 4, 5 };

        // Concatenating two lists
        var concatResult = list1.Concat(list2);
        Console.WriteLine(string.Join(", ", concatResult)); // Outputs : 1, 2, 3, 3, 4, 5

        // Union of two lists ( removes duplicates )
        var unionResult = list1.Union(list2);
        Console.WriteLine(string.Join(", ", unionResult)); // Outputs : 1, 2, 3, 4, 5
    }
}
```

## 17.What is the difference between ‘Take‘ and ‘Skip‘ in LINQ, and when would you use them?

**Answer :**

* **Take**: Returns a specified number of elements from the start of a sequence.
* **Skip**: Ignores a specified number of elements, returning the rest.

```csharp
class Program
{
    static void Main ()
    {
        var numbers = new List<int> { 1, 2, 3, 4, 5, 6 };

        // Take the first 3 elements
        var taken = numbers.Take(3);
        Console.WriteLine(string.Join(", ", taken)); // Outputs : 1, 2, 3

        // Skip the first 3 elements and return the rest
        var skipped = numbers.Skip(3);
        Console.WriteLine(string.Join(", ", skipped)); // Outputs : 4, 5, 6
    }
}
```

## 19.How does the ‘ToLookup‘ method differ from ‘GroupBy‘ in LINQ?

**Answer :**

‘ToLookup‘ returns an immutable `Lookup<TKey, TElement>` that you can query quickly,
while ‘GroupBy‘ returns an `IEnumerable<IGrouping<TKey, TElement>>`.
Semantically similar, but ‘Lookup‘ is more like a dictionary of lists.

```csharp
class Person
{
    public string Name { get; set; }
    public string Department { get; set; }
}

class Program
{
    static void Main ()
    {
        var people = new List<Person>
        {
            new Person { Name = "Alice", Department = "HR" },
            new Person { Name = "Bob", Department = "IT" },
            new Person { Name = "Charlie", Department = "HR" }
        };

        // Using GroupBy
        var grouped = people.GroupBy(p => p.Department);
        foreach (var group in grouped)
        {
            Console.WriteLine($"{group.Key}: {string.Join(", ", group.Select(p => p.Name))}");
        }

        // Using ToLookup
        var lookup = people.ToLookup(p => p.Department);
        foreach (var person in lookup["HR"]) // Quick lookup by key
        {
            Console.WriteLine(person.Name); // Outputs : Alice , Charlie
        }
    }
}
```

## 20.How does ‘Except‘ differ from ‘Distinct‘ in LINQ, and when would you use each?

**Answer :**

* **Except**: Computes set difference between two sequences.
* **Distinct**: Removes duplicates within a single sequence.

```csharp
class Program
{
    static void Main ()
    {
        var list1 = new List<int> { 1, 2, 3, 4 };
        var list2 = new List<int> { 3, 4, 5 };

        // Using Except : Elements in list1 but not in list2
        var exceptResult = list1.Except(list2);
        Console.WriteLine(string.Join(", ", exceptResult)); // Outputs : 1, 2

        // Using Distinct : Removes duplicates in a single list
        var listWithDuplicates = new List<int> { 1, 2, 2, 3, 4, 4 };
        var distinctResult = listWithDuplicates.Distinct();
        Console.WriteLine(string.Join(", ", distinctResult)); // Outputs : 1, 2, 3, 4
    }
}
```

## 21.How does ‘Reverse‘ work in LINQ, and what are some practical use cases?

**Answer :**

‘Reverse‘ inverts the order of a sequence.
Useful for reversing sort orders or processing items backward.

```csharp
class Program
{
    static void Main ()
    {
        var numbers = new List<int> { 1, 2, 3, 4, 5 };

        // Reverse the sequence
        var reversedNumbers = numbers.Reverse();
        Console.WriteLine(string.Join(", ", reversedNumbers)); // Outputs : 5, 4, 3, 2, 1
    }
}
```

## 22.What is the purpose of the ‘OfType‘ method in LINQ, and how does it differ from ‘Cast‘?

**Answer :**

* **OfType**: Filters elements that can be cast to the specified type, excluding invalid ones.
* **Cast**: Attempts to cast all elements, throwing if any cannot be cast.

```csharp
class Program
{
    static void Main ()
    {
        var mixedList = new List<object> { 1, "string", 3, "another string" };

        // OfType : Filters by type and ignores non - matching elements
        var intResults = mixedList.OfType<int>();
        Console.WriteLine(string.Join(", ", intResults)); // Outputs : 1, 3

        // Cast : Attempts to cast every element , throws exception if type mismatch occurs
        try
        {
            var castResults = mixedList.Cast<int>();
            Console.WriteLine(string.Join(", ", castResults)); // Throws InvalidCastException
        }
        catch (InvalidCastException ex)
        {
            Console.WriteLine(ex.Message);
        }
    }
}
```
