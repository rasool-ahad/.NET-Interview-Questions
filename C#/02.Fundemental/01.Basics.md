# Basics

**1. What is the difference between ‘const‘ and ‘readonly‘ in C#, and when would you use each?**

**Answer** :

‘const‘ is a compile-time constant, meaning its value is fixed and known at compile-time and cannot be modified.
It must be initialized at the time of declaration. 
On the other hand, ‘readonly‘ is a runtime constant, which can be assigned either at the time of declaration or within a constructor. ‘readonly‘ allows you to set values dynamically during object instantiation but prevents modification after that.

```Csharp
    public class Constants
    {
        public const int MaxSize = 100; // Must be assigned at compile time
        public readonly int MinSize ; // Can be assigned at runtime

        public Constants (int minSize )
        {
            MinSize = minSize ; // Allowed in constructor
        }
    }     
```

**2. What is the difference between ‘abstract‘ classes and ‘interfaces‘ in C#, and when would you use each?**

**Answer** :

An ‘abstract‘ class can provide both implementation and abstract members (methods or properties without implementation), while an ‘interface‘ can only define method signatures (starting with C# 8.0, interfaces can also have default implementations). You use an abstract class when classes share common behavior, but you want to force them to implement certain methods. Use an interface when you want to define a contract for behavior without prescribing any specific implementation

```Csharp
    // Abstract class with a method implementation
    public abstract class Shape
    {
        public abstract double Area (); // Abstract method
        public void Display() => Console . WriteLine ("I am a shape ");
    }
    // Interface with method signature
    public interface IShape
    {
        double Area ();
    }

    // Class that extends an abstract class
    public class Circle : Shape
    {
        public double Radius { get ; set ; }
        public override double Area() => Math .PI * Radius * Radius ;
    }

    // Class that implements an interface
    public class Rectangle : IShape
    {
        public double Length { get ; set ; }
        public double Width { get ; set ; }
        public double Area() => Length * Width ;
    }    
```

**3. What are extension methods in C# and how do they work?**

**Answer** :

Extension methods allow you to add new methods to existing types without modifying the original type or creating a new derived type. Extension methods are defined as static methods in a static class, and they use the ‘this‘ keyword in their first parameter to specify the type they extend

```Csharp
    public static class StringExtensions
    {
        // Extension method for the string class
        public static bool IsNullOrEmpty ( this string str)
        {
            return string . IsNullOrEmpty ( str );
        }
    }

    class Program
    {
        static void Main ()
        {
            string message = "Hello , World !";
            bool result = message . IsNullOrEmpty (); // Using the extension method
            Console . WriteLine ( result ); // Outputs False
        }
    }  
```

**4. What is the purpose of the ‘lock‘ statement in C#, and how does it prevent threading issues?**

**Answer** :

The ‘lock‘ statement in C# is used to ensure that a block of code is executed by only one thread at a time. 
It helps prevent **race conditions** by ensuring that only one thread can access the locked section of code. ‘lock‘ is typically used in scenarios where shared resources need to be accessed by multiple threads simultaneously.

```Csharp
    public class Counter
    {
        private int _count = 0;
        private readonly object _lock = new object ();

        public void Increment ()
        {
            // Only one thread can execute this block at a time
            lock(_lock )
            {
            _count ++;
            }
        }

        public int GetCount ()
        {
            return _count ;
        }
    } 
```

**5. What is covariance and contravariance in C#, and how do they apply to generics?**

**Answer** :

Covariance allows a method to return a more derived type than originally specified, while contravariance allows a method to accept parameters that are less derived than originally specified. In C#, covariance and contravariance are used with generics, delegates, and interfaces. They allow you to implicitly convert types in inheritance hierarchies

```Csharp
    // Covariance : Returning a derived type
    public interface ICovariant < out T> { }
    public class Animal { }
    public class Dog : Animal { }

    // Contravariance : Accepting a base type
    public interface IContravariant <in T> { }

    class Program
    {
        static void Main ()
        {
            // Covariance example : ICovariant < Animal > can hold ICovariant <Dog >
            ICovariant <Animal> animals = new ICovariant<Dog>();

            // Contravariance example : IContravariant <Dog > can hold IContravariant < Animal >
            IContravariant <Dog> dogs = new IContravariant<Animal>();
        }
    }
```

**6. What are expression-bodied members in C# and when would you use them?**

**Answer** :

Expression-bodied members allow concise syntax for methods, properties, and other members when the implementation is a single expression. They simplify the code and enhance readability

```Csharp
    public class Circle
    {
        public double Radius { get ; set ; }

        // Expression - bodied property
        public double Area => Math .PI * Radius * Radius ;

        // Expression - bodied method
        public double Circumference () => 2 * Math .PI * Radius ;
    }
```

**7. What is the difference between ‘Task‘ and ‘Thread‘ in C#?**

**Answer** :

A ‘Task‘ represents an asynchronous operation and is part of the **Task Parallel Library (TPL)**.
Tasks are higher-level abstractions over threads and provide better control over asynchronous code execution. 
A ‘Thread‘, on the other hand, represents an individual thread of execution. Tasks are preferred for background work, as they are more efficient and offer more features such as cancellation and continuation.

```Csharp
    class Program
    {
        static void Main ()
        {
            // Using Task for asynchronous work
            Task.Run(() => DoWork());

            // Using Thread for lower - level threading
            Thread thread = new Thread ( DoWork );
            thread . Start ();
        }

        static void DoWork ()
        {
            Console . WriteLine (" Work is being done .");
        }
    }
```

**8. What is the purpose of `async` and `await` in C#?**

**Answer** :

`async` and `await` are used to write asynchronous code in a readable, sequential style.
They allow long-running operations to execute without blocking the main thread, improving application responsiveness, especially in GUI and web applications.

```csharp
public async Task<int> FetchDataAsync()
{
    // Asynchronous call to simulate data fetching
    await Task.Delay(2000);
    return 42;
}

class Program
{
    static async Task Main(string[] args)
    {
        Console.WriteLine("Fetching data...");
        int result = await FetchDataAsync();
        Console.WriteLine($"Data fetched: {result}");
    }
}
```

**9. What are delegates in C#, and how do they differ from events?**

**Answer** :

A delegate is a type that represents references to methods with a specific signature and is commonly used for callbacks.
Events are a specialized form of delegates used for notifications and provide encapsulation by restricting invocation to the defining class only.

```csharp
// Delegate definition
public delegate void Notify();

// Publisher class
public class ProcessBusinessLogic
{
    public event Notify ProcessCompleted;

    public void StartProcess()
    {
        Console.WriteLine("Process started.");
        OnProcessCompleted();
    }

    protected virtual void OnProcessCompleted()
    {
        ProcessCompleted?.Invoke();
    }
}

class Program
{
    static void Main(string[] args)
    {
        ProcessBusinessLogic bl = new ProcessBusinessLogic();
        bl.ProcessCompleted += () => Console.WriteLine("Process completed.");
        bl.StartProcess();
    }
}
```

**10. What is `IDisposable` and the purpose of the `using` statement in C#?**

**Answer** :

`IDisposable` is an interface used to release unmanaged resources explicitly.
The `using` statement ensures that `Dispose` is automatically called when the object goes out of scope.

```csharp
public class Resource : IDisposable
{
    public void Dispose()
    {
        Console.WriteLine("Resources have been released.");
    }
}

class Program
{
    static void Main()
    {
        using (var resource = new Resource())
        {
            // Work with the resource
        } // Dispose is called automatically here
    }
}
```

**11. What is the difference between `IEnumerable` and `IQueryable` in C#?**

**Answer** :

`IEnumerable` is used for in-memory data processing and executes queries locally.
`IQueryable` is used for querying external data sources such as databases and allows query translation (e.g., LINQ to SQL).

```csharp
IEnumerable<int> numbers = new List<int> { 1, 2, 3, 4 };
var evenNumbers = numbers.Where(n => n % 2 == 0); // In-memory filtering

IQueryable<int> queryableNumbers = numbers.AsQueryable();
var queryableEvenNumbers = queryableNumbers.Where(n => n % 2 == 0); // Optimized filtering
```

**12. What is Dependency Injection in C#, and how is it implemented?**

**Answer** :

Dependency Injection (DI) is a design pattern that reduces tight coupling by supplying dependencies from outside the class.
In C#, it is commonly implemented using the built-in DI container in ASP.NET Core.

```csharp
public interface ILogger
{
    void Log(string message);
}

public class ConsoleLogger : ILogger
{
    public void Log(string message) => Console.WriteLine(message);
}

public class Application
{
    private readonly ILogger _logger;

    public Application(ILogger logger)
    {
        _logger = logger;
    }

    public void Run() => _logger.Log("Application running.");
}

// services.AddSingleton<ILogger, ConsoleLogger>();
// services.AddTransient<Application>();
```

**13. What is the difference between `Finalize` and `Dispose` in C#?**

**Answer** :

`Dispose` is used for deterministic cleanup of unmanaged resources.
`Finalize` (destructor) is called by the garbage collector as a fallback mechanism if `Dispose` is not called.

```csharp
public class Resource : IDisposable
{
    public void Dispose()
    {
        // Explicit resource cleanup
    }

    ~Resource()
    {
        Dispose();
    }
}
```

**14. What is the `volatile` keyword in C#, and when would you use it?**

**Answer** :

The `volatile` keyword ensures that a field is always read from main memory, preventing compiler optimizations that may cache its value.
It is used in multi-threaded scenarios.

```csharp
public class Worker
{
    private volatile bool _isRunning = true;

    public void Stop()
    {
        _isRunning = false;
    }

    public void DoWork()
    {
        while (_isRunning)
        {
            // Perform work
        }
    }
}
```

**15. What are `Func`, `Action`, and `Predicate` delegates in C#?**

**Answer** :

* `Func<T, TResult>` returns a value.
* `Action<T>` does not return a value.
* `Predicate<T>` returns a boolean and accepts one parameter.

```csharp
Func<int, int, int> add = (a, b) => a + b;
Action<string> print = message => Console.WriteLine(message);
Predicate<int> isEven = number => number % 2 == 0;
```

**16. What are asynchronous streams in C# and how do they work?**

**Answer** :

Asynchronous streams allow consuming data asynchronously using `await foreach`.
They are useful when data is produced over time.

```csharp
public async IAsyncEnumerable<int> GetNumbersAsync()
{
    for (int i = 0; i < 5; i++)
    {
        await Task.Delay(1000);
        yield return i;
    }
}

public async Task ProcessNumbersAsync()
{
    await foreach (var number in GetNumbersAsync())
    {
        Console.WriteLine(number);
    }
}
```

**17. What is boxing and unboxing in C#? Why is it important?**

**Answer** :

Boxing converts a value type to an object type.
Unboxing converts it back to a value type.
These operations cause performance overhead due to heap allocation and casting.

```csharp
int value = 42;
object boxedValue = value;       // Boxing
int unboxedValue = (int)boxedValue; // Unboxing
```

**18. How does the `async`/`await` mechanism handle exceptions in C#?**

**Answer** :

Exceptions thrown in asynchronous code are captured and re-thrown when awaited.
They can be handled using standard `try-catch` blocks.

```csharp
public async Task FetchDataAsync()
{
    try
    {
        await Task.Run(() => throw new InvalidOperationException("An error occurred"));
    }
    catch (InvalidOperationException ex)
    {
        Console.WriteLine($"Exception caught: {ex.Message}");
    }
}
```


**19. What are tuples in C#, and how are they used?**

**Answer** :

Tuples are lightweight structures used to group multiple values.
C# 7.0 introduced value tuples, which support named elements.

```csharp
public (int, string) GetPerson()
{
    return (1, "John Doe");
}

var person = GetPerson();
Console.WriteLine($"ID: {person.Item1}, Name: {person.Item2}");
```

**20. What is the difference between `Thread.Sleep` and `Task.Delay` in C#?**

**Answer** :

`Thread.Sleep` blocks the current thread.
`Task.Delay` is non-blocking and should be used in asynchronous programming.

```csharp
Thread.Sleep(1000);      // Blocks the thread

await Task.Delay(1000); // Non-blocking delay
```