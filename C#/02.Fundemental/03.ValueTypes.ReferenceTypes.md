# Value Types, Reference Types, Immutable, Semantics

**1. What is the difference between value types and reference types in C#?**

**Answer :**

Value types store the actual data directly and are typically stored on the stack. When a value type is assigned to another variable, a full copy of the data is created.
Reference types store a reference (memory address) to the data, which is stored on the heap. Assigning a reference type copies the reference, not the actual object, so multiple variables can point to the same memory location.

```Csharp
struct ValueTypeExample
{
    public int x;
}

class ReferenceTypeExample
{
    public int x;
}

class Program
{
    static void Main()
    {
        // Value type
        ValueTypeExample v1 = new ValueTypeExample { x = 10 };
        ValueTypeExample v2 = v1; // Copy
        v2.x = 20;

        // Reference type
        ReferenceTypeExample r1 = new ReferenceTypeExample { x = 10 };
        ReferenceTypeExample r2 = r1; // Same reference
        r2.x = 20;

        Console.WriteLine($"Value Type: v1.x = {v1.x}, v2.x = {v2.x}");
        Console.WriteLine($"Reference Type: r1.x = {r1.x}, r2.x = {r2.x}");
    }
}
```

**2. How does boxing and unboxing work in C#?**

**Answer :**

Boxing is the process of converting a value type into an object type, which allocates memory on the heap.
Unboxing extracts the value type from the object. Boxing and unboxing introduce performance overhead due to heap allocation and type conversion.

```Csharp
class Program
{
    static void Main()
    {
        int value = 123;
        object boxed = value;          // Boxing
        int unboxed = (int)boxed;      // Unboxing

        Console.WriteLine($"Boxed: {boxed}, Unboxed: {unboxed}");
    }
}
```

**3. What is the difference between mutable and immutable types in C#?**

**Answer :**

Mutable types can be modified after creation, while immutable types cannot be changed once they are created.
Strings are immutable, whereas most custom classes are mutable unless explicitly designed otherwise.

```Csharp
class MutableClass
{
    public int Value { get; set; }
}

class ImmutableClass
{
    public int Value { get; }

    public ImmutableClass(int value)
    {
        Value = value;
    }
}

class Program
{
    static void Main()
    {
        var mutable = new MutableClass { Value = 10 };
        mutable.Value = 20;

        var immutable = new ImmutableClass(10);
        // immutable.Value = 20; // Compile-time error
    }
}
```

**4. What are the performance implications of value types vs. reference types?**

**Answer :**

Value types can provide better performance for small data because they avoid heap allocation. However, copying large value types can be expensive.
Reference types are allocated on the heap and managed by the garbage collector, which can introduce runtime overhead.

```Csharp
struct PointValueType
{
    public int X, Y;
}

class PointReferenceType
{
    public int X, Y;
}

class Program
{
    static void Main()
    {
        PointValueType p1 = new PointValueType { X = 10, Y = 20 };
        PointValueType p2 = p1; // Copy

        PointReferenceType r1 = new PointReferenceType { X = 10, Y = 20 };
        PointReferenceType r2 = r1; // Shared reference
    }
}
```

**5. How do structs and classes differ in terms of copying semantics in C#?**

**Answer :**

Structs are value types and are copied by value.
Classes are reference types and are copied by reference, meaning both variables point to the same object.

```Csharp
struct StructExample
{
    public int X;
}

class ClassExample
{
    public int X;
}

class Program
{
    static void Main()
    {
        StructExample s1 = new StructExample { X = 10 };
        StructExample s2 = s1;
        s2.X = 20;

        ClassExample c1 = new ClassExample { X = 10 };
        ClassExample c2 = c1;
        c2.X = 20;
    }
}
```

**6. What are the common pitfalls of using mutable reference types in C#?**

**Answer :**

Mutable reference types can cause unintended side effects because multiple variables may reference the same object. Changes made through one reference affect all others.

```Csharp
class MutableExample
{
    public int Value { get; set; }
}

class Program
{
    static void Main()
    {
        MutableExample obj1 = new MutableExample { Value = 10 };
        MutableExample obj2 = obj1;
        obj2.Value = 20;

        Console.WriteLine(obj1.Value); // Outputs 20
    }
}
```

**7. How does the `in` parameter modifier affect value types in C#?**

**Answer :**

The `in` keyword passes a value type by reference while preventing modification.
It is useful for passing large structs efficiently without copying.

```Csharp
struct LargeStruct
{
    public int X;
    public int Y;
}

class Program
{
    static void DisplayCoordinates(in LargeStruct point)
    {
        Console.WriteLine($"X: {point.X}, Y: {point.Y}");
    }

    static void Main()
    {
        LargeStruct point = new LargeStruct { X = 5, Y = 10 };
        DisplayCoordinates(in point);
    }
}
```

**8. What are the key differences between shallow copy and deep copy in C#?**

**Answer :**

A shallow copy copies only the top-level object and shares referenced objects.
A deep copy duplicates the object and all referenced objects, creating full independence.

```Csharp
class Person
{
    public string Name { get; set; }
    public Address Address { get; set; }
}

class Address
{
    public string City { get; set; }
}

class Program
{
    static void Main()
    {
        Person person1 = new Person
        {
            Name = "John",
            Address = new Address { City = "NY" }
        };

        Person person2 = person1; // Shallow copy
        person2.Address.City = "LA";

        Console.WriteLine(person1.Address.City); // Outputs LA
    }
}
```

**9. How does the `ref` keyword affect parameters in C#?**

**Answer :**

The `ref` keyword allows both value and reference types to be passed by reference, enabling modifications inside the method to affect the original variable.

```Csharp
class Program
{
    static void ModifyValue(ref int value)
    {
        value = 20;
    }

    static void Main()
    {
        int number = 10;
        ModifyValue(ref number);
        Console.WriteLine(number); // Outputs 20
    }
}
```

**10. What are tuples in C#, and are they value types or reference types?**

**Answer :**

Tuples are lightweight data structures used to store multiple values.
In C# 7.0+, tuples are value types and are mutable.

```Csharp
class Program
{
    static (int, string) GetData()
    {
        return (1, "example");
    }

    static void Main()
    {
        var tuple = GetData();
        Console.WriteLine($"ID: {tuple.Item1}, Name: {tuple.Item2}");
    }
}
```

**11. What is semantic meaning in C#, and how does it differ from syntax?**

**Answer :**

Syntax refers to the rules for writing valid code, while semantics refers to the meaning and behavior of that code at runtime.
Code can be syntactically correct but semantically incorrect.

```Csharp
class Program
{
    static void Main()
    {
        int x = 5;
        int y = 0;

        int result = x / y; // Runtime error (semantic issue)
    }
}
```

**12. How can you implement immutability in C# for custom objects?**

**Answer :**

Immutability is achieved by using read-only properties and initializing all values through the constructor.

```Csharp
class ImmutablePerson
{
    public string Name { get; }
    public int Age { get; }

    public ImmutablePerson(string name, int age)
    {
        Name = name;
        Age = age;
    }
}
```

**13. How does the garbage collector handle value types and reference types differently?**

**Answer :**

Value types are usually stored on the stack and are cleaned up automatically when they go out of scope.
Reference types are stored on the heap and cleaned up by the garbage collector when no references remain.

```Csharp
class Program
{
    static void Main()
    {
        int value = 10;          // Value type
        object reference = new object(); // Reference type
    }
}
```

**14. Why should you avoid using mutable value types in C#?**

**Answer :**

Mutable value types can cause confusion because they are copied by value. Modifying a copy does not affect the original instance.

```Csharp
struct MutableStruct
{
    public int Value;
}

class Program
{
    static void ModifyStruct(MutableStruct s)
    {
        s.Value = 20;
    }

    static void Main()
    {
        MutableStruct s = new MutableStruct { Value = 10 };
        ModifyStruct(s);
        Console.WriteLine(s.Value); // Outputs 10
    }
}
```

**15. What is `readonly struct` in C#, and when would you use it?**

**Answer :**

A `readonly struct` ensures all fields are immutable after initialization and avoids defensive copying, improving performance.

```Csharp
readonly struct ReadonlyPoint
{
    public int X { get; }
    public int Y { get; }

    public ReadonlyPoint(int x, int y)
    {
        X = x;
        Y = y;
    }
}
```

**16. What are default values for value types and reference types in C#?**

**Answer :**

Value types have default values (e.g., `0`, `false`), while reference types default to `null`.

```Csharp
class Program
{
    static void Main()
    {
        int defaultValue = default(int);
        object defaultReference = default(object);

        Console.WriteLine(defaultValue);      // 0
        Console.WriteLine(defaultReference);  // null
    }
}
```
